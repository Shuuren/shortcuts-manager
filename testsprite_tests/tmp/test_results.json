[
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "fa125e03-e41e-4a84-89fe-d022b408a907",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC001-user registration with unique username",
    "description": "Test the /api/auth/register endpoint to ensure a new user can register with a unique username, password, and optional display name. Verify that the user is assigned the 'client' role by default and a JWT token is returned. Also test that duplicate usernames return a 400 error.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/api/auth/register\"\nTIMEOUT = 30\n\ndef test_user_registration_unique_username():\n    # Generate unique username\n    unique_username = f\"testuser_{uuid.uuid4().hex[:8]}\"\n    password = \"TestPassword123!\"\n    display_name = \"Test DisplayName\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Payload for registration\n    payload = {\n        \"username\": unique_username,\n        \"password\": password,\n        \"displayName\": display_name\n    }\n\n    # 1. Register new user with unique username - expect 201 created\n    try:\n        response = requests.post(REGISTER_ENDPOINT, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to register user failed: {e}\"\n\n    assert response.status_code == 201, f\"Expected HTTP 201 for new user registration, got {response.status_code}\"\n    json_data = response.json()\n    assert \"user\" in json_data, \"'user' field missing in response\"\n    assert \"token\" in json_data, \"'token' field missing in response\"\n    user = json_data[\"user\"]\n    # Validate fields and role\n    assert user.get(\"username\") == unique_username.lower(), \"Username in response does not match (should be lowercased)\"\n    expected_display_name = display_name if display_name else unique_username.lower()\n    assert user.get(\"displayName\") == expected_display_name, \"Display name in response does not match\"\n    assert user.get(\"role\") == \"client\", \"User role should be 'client' by default\"\n    assert isinstance(json_data[\"token\"], str) and len(json_data[\"token\"]) > 0, \"JWT token is missing or empty\"\n\n    # 2. Attempt to register again with same username - expect 400 error for duplicate username\n    dup_payload = {\n        \"username\": unique_username,\n        \"password\": \"AnotherPassword123!\",\n        \"displayName\": \"Another DisplayName\"\n    }\n    try:\n        dup_response = requests.post(REGISTER_ENDPOINT, json=dup_payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to register duplicate user failed: {e}\"\n\n    assert dup_response.status_code == 400, f\"Expected HTTP 400 for duplicate username registration, got {dup_response.status_code}\"\n\ntest_user_registration_unique_username()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.027Z",
    "modified": "2025-12-13T14:23:18.617Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "303997eb-f9b5-4377-9ba7-c140f0f842c1",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC002-user login with valid credentials",
    "description": "Test the /api/auth/login endpoint to verify that users can log in with valid username and password, receiving a JWT token and user details including role. Verify that invalid credentials return a 401 error.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/login\"\nTIMEOUT = 30\n\ndef test_user_login_with_valid_credentials():\n    # Define valid and invalid credentials for testing\n    valid_credentials = {\n        \"username\": \"testuser_valid\",\n        \"password\": \"TestPass123!\"\n    }\n    invalid_credentials = {\n        \"username\": \"testuser_valid\",\n        \"password\": \"WrongPass!\"\n    }\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        # First, to ensure the valid user exists, attempt login:\n        response = requests.post(\n            LOGIN_ENDPOINT,\n            json=valid_credentials,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        # Successful login should return HTTP 200\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n\n        data = response.json()\n        # Assert presence and validity of token and user information\n        assert \"token\" in data and isinstance(data[\"token\"], str) and data[\"token\"], \"JWT token missing or invalid\"\n        assert \"user\" in data and isinstance(data[\"user\"], dict), \"User details missing or invalid\"\n        user = data[\"user\"]\n        # Validate required user fields\n        assert \"id\" in user and isinstance(user[\"id\"], str) and user[\"id\"], \"User ID missing or invalid\"\n        assert user.get(\"username\") == valid_credentials[\"username\"], f\"Username mismatch: expected {valid_credentials['username']}, got {user.get('username')}\"\n        assert \"role\" in user and user[\"role\"] in {\"admin\", \"demo\", \"client\"}, f\"User role invalid or missing: {user.get('role')}\"\n\n        # Now test invalid credentials\n        response_invalid = requests.post(\n            LOGIN_ENDPOINT,\n            json=invalid_credentials,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        # Invalid login should return HTTP 401\n        assert response_invalid.status_code == 401, f\"Expected status 401 for invalid credentials, got {response_invalid.status_code}\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_user_login_with_valid_credentials()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 56, in <module>\n  File \"<string>\", line 31, in test_user_login_with_valid_credentials\nAssertionError: Expected status 200, got 401\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.033Z",
    "modified": "2025-12-13T14:23:42.149Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "0c2ebae7-c02b-4a5a-bf30-9336e0a672c8",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC003-get authenticated user profile",
    "description": "Test the /api/auth/me GET endpoint to retrieve the current authenticated user's profile information. Verify that the endpoint requires a valid JWT token and returns 404 if the user is not found.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_get_authenticated_user_profile():\n    # First, register a new user uniquely for this test\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    me_url = f\"{BASE_URL}/api/auth/me\"\n    test_username = \"testuser_tc003\"\n    test_password = \"TestPass123!\"\n    test_display_name = \"Test User TC003\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register user\n    reg_payload = {\n        \"username\": test_username,\n        \"password\": test_password,\n        \"displayName\": test_display_name\n    }\n    reg_response = requests.post(register_url, json=reg_payload, headers=headers, timeout=TIMEOUT)\n    assert reg_response.status_code == 201, f\"User registration failed: {reg_response.text}\"\n    reg_json = reg_response.json()\n    assert \"token\" in reg_json and \"user\" in reg_json, \"Registration response missing token or user\"\n\n    # Login user to get valid token (to ensure token is valid and fresh)\n    login_payload = {\n        \"username\": test_username,\n        \"password\": test_password\n    }\n    login_response = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n    assert login_response.status_code == 200, f\"User login failed: {login_response.text}\"\n    login_json = login_response.json()\n    assert \"token\" in login_json and \"user\" in login_json, \"Login response missing token or user\"\n    token = login_json[\"token\"]\n\n    try:\n        # Test with valid token - should succeed and return user profile matching logged in user\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n        me_response = requests.get(me_url, headers=auth_headers, timeout=TIMEOUT)\n        assert me_response.status_code == 200, f\"Get profile failed with valid token: {me_response.text}\"\n        profile = me_response.json()\n        assert profile.get(\"username\") == test_username, \"Profile username mismatch\"\n        assert profile.get(\"displayName\") == test_display_name, \"Profile displayName mismatch\"\n        assert \"id\" in profile and \"role\" in profile, \"Profile missing required fields\"\n\n        # Test with missing token - expect 401 Unauthorized or equivalent (not documented, test common practice)\n        no_auth_response = requests.get(me_url, timeout=TIMEOUT)\n        # The API requires valid JWT token so expect 401/403, 404 is for user not found only with valid token\n        assert no_auth_response.status_code in (401, 403), f\"Expected 401 or 403 for missing token, got {no_auth_response.status_code}\"\n\n        # Test with invalid token - expect 401/403\n        invalid_headers = {\n            \"Authorization\": \"Bearer invalid.token.value\"\n        }\n        invalid_token_response = requests.get(me_url, headers=invalid_headers, timeout=TIMEOUT)\n        assert invalid_token_response.status_code in (401, 403), f\"Expected 401 or 403 for invalid token, got {invalid_token_response.status_code}\"\n\n        # Simulate user not found condition:\n        # Since user ID is from token, normally server would lookup user.\n        # We can try to modify the token payload or use a revoked token.\n        # However, since no direct method provided, test by deleting user then accessing.\n        # No endpoint provided to delete user, so this part can't be done directly.\n        # Instead, verify 404 on /api/auth/me if token valid but user not found.\n        # We will try to hack this by using a token for user that doesn't exist.\n        # Alternative: Use token from newly registered user, then after deleting user.\n        # Since no delete user endpoint or ability, skip this part.\n\n    finally:\n        # Clean up: no user deletion endpoint documented, so no cleanup possible.\n        # In a real scenario, we would delete the created user here.\n        pass\n\ntest_get_authenticated_user_profile()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.039Z",
    "modified": "2025-12-13T14:23:24.372Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "ab47f47f-1afc-41af-b019-229fcff15a3b",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC004-update user profile with password validation",
    "description": "Test the /api/auth/me PUT endpoint to update the user's display name and/or password. Verify that changing the password requires the current password and returns 400 if missing or 401 if incorrect. Confirm that a new JWT token is issued upon successful update.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_update_user_profile_with_password_validation():\n    # Step 1: Register a new user to test with\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    username = f\"testuser_{uuid.uuid4().hex[:8]}\"\n    password = \"OldPassword123!\"\n    display_name = \"Initial DisplayName\"\n    register_payload = {\n        \"username\": username,\n        \"password\": password,\n        \"displayName\": display_name\n    }\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"User registration failed: {reg_resp.text}\"\n        reg_data = reg_resp.json()\n        token = reg_data.get(\"token\")\n        assert token, \"No token returned on registration\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        update_url = f\"{BASE_URL}/api/auth/me\"\n\n        # Step 2: Attempt to change password without currentPassword -> Expect 400\n        payload_missing_current = {\n            \"newPassword\": \"NewPassword456!\",\n            \"displayName\": \"Updated DisplayName\"\n        }\n        resp_missing_current = requests.put(update_url, json=payload_missing_current, headers=headers, timeout=TIMEOUT)\n        assert resp_missing_current.status_code == 400, (\n            f\"Expected 400 for missing currentPassword, got {resp_missing_current.status_code}\")\n\n        # Step 3: Attempt to change password with incorrect currentPassword -> Expect 401\n        payload_wrong_current = {\n            \"currentPassword\": \"WrongPassword!\",\n            \"newPassword\": \"NewPassword456!\",\n            \"displayName\": \"Updated DisplayName\"\n        }\n        resp_wrong_current = requests.put(update_url, json=payload_wrong_current, headers=headers, timeout=TIMEOUT)\n        assert resp_wrong_current.status_code == 401, (\n            f\"Expected 401 for incorrect currentPassword, got {resp_wrong_current.status_code}\")\n\n        # Step 4: Successful update - change displayName only (no password change)\n        payload_update_displayname = {\n            \"displayName\": \"Updated DisplayName Only\"\n        }\n        resp_update_displayname = requests.put(update_url, json=payload_update_displayname, headers=headers, timeout=TIMEOUT)\n        assert resp_update_displayname.status_code == 200, (\n            f\"Failed to update displayName only: {resp_update_displayname.text}\")\n        data_displayname = resp_update_displayname.json()\n        user_data = data_displayname.get(\"user\")\n        new_token = data_displayname.get(\"token\")\n        assert user_data is not None, \"No user object in response\"\n        assert user_data.get(\"displayName\") == \"Updated DisplayName Only\", \"DisplayName was not updated\"\n        assert new_token is not None, \"No new JWT token issued after displayName update\"\n\n        # Step 5: Successful update - change password with correct currentPassword\n        payload_change_password = {\n            \"currentPassword\": password,\n            \"newPassword\": \"NewPassword456!\",\n            \"displayName\": \"Updated DisplayName Final\"\n        }\n        # Use the new token for authorization\n        headers_password_change = {\n            \"Authorization\": f\"Bearer {new_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n        resp_change_password = requests.put(update_url, json=payload_change_password, headers=headers_password_change, timeout=TIMEOUT)\n        assert resp_change_password.status_code == 200, (\n            f\"Failed to update password: {resp_change_password.text}\")\n        data_password = resp_change_password.json()\n        user_after_pw = data_password.get(\"user\")\n        new_token_after_pw = data_password.get(\"token\")\n        assert user_after_pw is not None, \"No user object in response after password change\"\n        assert user_after_pw.get(\"displayName\") == \"Updated DisplayName Final\", \"DisplayName was not updated on password change\"\n        assert new_token_after_pw is not None, \"No new JWT token issued after password change\"\n\n        # Step 6: Verify login with old password fails\n        login_url = f\"{BASE_URL}/api/auth/login\"\n        login_old_pw_payload = {\n            \"username\": username,\n            \"password\": password\n        }\n        resp_login_old_pw = requests.post(login_url, json=login_old_pw_payload, timeout=TIMEOUT)\n        assert resp_login_old_pw.status_code == 401, \"Old password should not work after password change\"\n\n        # Step 7: Verify login with new password succeeds\n        login_new_pw_payload = {\n            \"username\": username,\n            \"password\": \"NewPassword456!\"\n        }\n        resp_login_new_pw = requests.post(login_url, json=login_new_pw_payload, timeout=TIMEOUT)\n        assert resp_login_new_pw.status_code == 200, \"Login with new password failed\"\n        login_data = resp_login_new_pw.json()\n        assert \"token\" in login_data, \"No token returned on login with new password\"\n\n    finally:\n        # Cleanup: Delete the created user if API to delete user exists (not specified in PRD)\n        # Since there's no delete user endpoint in the PRD, skip cleanup.\n        pass\n\ntest_update_user_profile_with_password_validation()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.046Z",
    "modified": "2025-12-13T14:23:38.576Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "2ae658b1-8ff0-42cb-adbf-ac9e565af8e9",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC005-get all shortcuts data based on user role",
    "description": "Test the /api/shortcuts GET endpoint to ensure it returns the correct shortcuts, groups, and apps data based on the authenticated user's role: admin users receive full db.json data, demo and guest users receive demo_db.json data, and client users receive empty arrays.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef login(username: str, password: str) -> str:\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\"username\": username, \"password\": password}\n    try:\n        response = requests.post(url, json=payload, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        token = data.get(\"token\")\n        assert token, \"Login response missing token\"\n        return token\n    except requests.RequestException as e:\n        raise RuntimeError(f\"Login failed for user {username}: {str(e)}\")\n\ndef get_shortcuts(token: str):\n    url = f\"{BASE_URL}/api/shortcuts\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n        return response.json()\n    except requests.RequestException as e:\n        raise RuntimeError(f\"Get shortcuts failed: {str(e)}\")\n\ndef test_tc005_get_all_shortcuts_based_on_user_role():\n    # Define test users and expected results per role\n    users = {\n        \"admin\": {\"username\": \"admin_test\", \"password\": \"admin_password\"},\n        \"demo\": {\"username\": \"demo_test\", \"password\": \"demo_password\"},\n        \"client\": {\"username\": \"client_test\", \"password\": \"client_password\"},\n        \"guest\": None  # guest means no auth token, should receive demo_db.json data\n    }\n\n    # Expected keys for the data\n    expected_keys = {\n        \"leaderShortcuts\",\n        \"raycastShortcuts\",\n        \"systemShortcuts\",\n        \"leaderGroups\",\n        \"appsLibrary\",\n        \"apps\"\n    }\n\n    def is_full_data(data):\n        # Admin gets full db.json data - arrays should be non-empty (assuming full data has shortcuts)\n        # We only check type here (lists) and non-empty as heuristic\n        if not all(k in data and isinstance(data[k], list) for k in expected_keys):\n            return False\n        # At least one of the shortcut lists should be non-empty to be considered full db.json\n        return any(len(data[k]) > 0 for k in [\"leaderShortcuts\", \"raycastShortcuts\", \"systemShortcuts\"])\n\n    def is_demo_data(data):\n        # Demo and guest get demo_db.json data - arrays present, expected to be non-empty but can be smaller than admin\n        if not all(k in data and isinstance(data[k], list) for k in expected_keys):\n            return False\n        # At least one shortcut list should be non-empty\n        return any(len(data[k]) > 0 for k in [\"leaderShortcuts\", \"raycastShortcuts\", \"systemShortcuts\"])\n\n    def is_empty_data(data):\n        # Client users receive empty arrays\n        if not all(k in data and isinstance(data[k], list) for k in expected_keys):\n            return False\n        return all(len(data[k]) == 0 for k in expected_keys)\n\n    # Admin user test\n    admin_token = login(users[\"admin\"][\"username\"], users[\"admin\"][\"password\"])\n    admin_data = get_shortcuts(admin_token)\n    assert is_full_data(admin_data), \"Admin user should receive full db.json data with non-empty shortcut arrays\"\n\n    # Demo user test\n    demo_token = login(users[\"demo\"][\"username\"], users[\"demo\"][\"password\"])\n    demo_data = get_shortcuts(demo_token)\n    assert is_demo_data(demo_data), \"Demo user should receive demo_db.json data with shortcut arrays present\"\n\n    # Client user test\n    client_token = login(users[\"client\"][\"username\"], users[\"client\"][\"password\"])\n    client_data = get_shortcuts(client_token)\n    assert is_empty_data(client_data), \"Client user should receive empty arrays for shortcuts, groups, and apps\"\n\n    # Guest user test - no authorization header\n    url = f\"{BASE_URL}/api/shortcuts\"\n    response = requests.get(url, timeout=TIMEOUT)\n    assert response.status_code == 200, f\"Guest user request failed with status {response.status_code}\"\n    guest_data = response.json()\n    assert is_demo_data(guest_data), \"Guest user should receive demo_db.json data with shortcut arrays present\"\n\ntest_tc005_get_all_shortcuts_based_on_user_role()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 11, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3001/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 91, in <module>\n  File \"<string>\", line 70, in test_tc005_get_all_shortcuts_based_on_user_role\n  File \"<string>\", line 17, in login\nRuntimeError: Login failed for user admin_test: 401 Client Error: Unauthorized for url: http://localhost:3001/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.052Z",
    "modified": "2025-12-13T14:23:42.133Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "63744cc4-ac75-4f08-adb8-072cd12798b2",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC006-create new shortcut group or app with authorization",
    "description": "Test the /api/shortcuts/{type} POST endpoint to create new shortcuts, groups, or apps. Verify that only admin and demo users can create items and that the type parameter correctly determines the collection. Unauthorized users should receive a 403 error.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n# Credentials for test users\nUSERS = {\n    \"admin\": {\"username\": \"admin\", \"password\": \"adminpass\"},\n    \"demo\": {\"username\": \"demo\", \"password\": \"demopass\"},\n    \"client\": {\"username\": \"client\", \"password\": \"clientpass\"},\n    \"guest\": None  # No auth for guest\n}\n\ndef login_get_token(username, password):\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json={\"username\": username, \"password\": password},\n            timeout=TIMEOUT,\n        )\n        response.raise_for_status()\n        data = response.json()\n        token = data.get(\"token\")\n        assert token, \"Token not found in login response\"\n        return token\n    except (RequestException, AssertionError) as e:\n        raise RuntimeError(f\"Login failed for user {username}: {e}\")\n\ndef create_item(token, type_, item_data):\n    headers = {\"Authorization\": f\"Bearer {token}\"} if token else {}\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/shortcuts/{type_}\",\n            json=item_data,\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        return resp\n    except RequestException as e:\n        raise RuntimeError(f\"Request to create item failed: {e}\")\n\ndef delete_item(token, type_, item_id):\n    headers = {\"Authorization\": f\"Bearer {token}\"} if token else {}\n    try:\n        resp = requests.delete(\n            f\"{BASE_URL}/api/shortcuts/{type_}/{item_id}\",\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        return resp\n    except RequestException as e:\n        raise RuntimeError(f\"Request to delete item failed: {e}\")\n\ndef test_create_new_shortcut_group_or_app_with_authorization():\n    # Item data samples for each collection type\n    sample_items = {\n        \"shortcuts\": {\n            # generic shortcut data\n            \"sequence\": [\"Ctrl\", \"Shift\", \"N\"],\n            \"category\": \"TestCategory\",\n            \"app\": \"TestApp\",\n            \"action\": \"TestAction\",\n            \"notes\": \"Test notes\",\n            \"appId\": \"app_test_123\"\n        },\n        \"groups\": {\n            \"name\": \"Test Group\",\n            \"icon\": \"test_icon\",\n            \"color\": \"#123456\"\n        },\n        \"apps\": {\n            \"name\": \"Test App\",\n            \"icon\": \"dGVzdF9pbWFnZQ==\",  # base64 encoded string 'test_image'\n            \"category\": \"Utility\",\n            \"linkedShortcuts\": []\n        },\n        \"leaderShortcuts\": {\n            \"sequence\": [\"Cmd\", \"L\"],\n            \"category\": \"LeaderCategory\",\n            \"app\": \"LeaderApp\",\n            \"action\": \"LeaderAction\",\n            \"notes\": None,\n            \"appId\": \"leader_app_id\"\n        },\n        \"raycastShortcuts\": {\n            \"action\": \"RaycastAction\",\n            \"key\": \"R\",\n            \"modifiers\": [\"Cmd\", \"Shift\"],\n            \"group\": \"RaycastGroup\",\n            \"type\": \"RaycastType\",\n            \"description\": \"Raycast test shortcut\"\n        },\n        \"systemShortcuts\": {\n            \"action\": \"SystemAction\",\n            \"key\": \"S\",\n            \"modifiers\": [\"Ctrl\"],\n            \"group\": \"SystemGroup\",\n            \"description\": None\n        },\n        \"leaderGroups\": {\n            \"name\": \"Leader Group\",\n            \"icon\": \"leader_icon_data\",\n            \"color\": \"#abcdef\"\n        },\n        \"raycastGroups\": {\n            \"name\": \"Raycast Group\",\n            \"icon\": \"raycast_icon_data\",\n            \"color\": \"#fedcba\"\n        },\n        \"systemGroups\": {\n            \"name\": \"System Group\",\n            \"icon\": \"system_icon_data\",\n            \"color\": \"#654321\"\n        }\n    }\n\n    authorized_users = [\"admin\", \"demo\"]\n    unauthorized_users = [\"client\", \"guest\"]\n    types_to_test = list(sample_items.keys())\n\n    for user_key in authorized_users + unauthorized_users:\n        creds = USERS[user_key]\n        token = None\n        if creds:\n            token = login_get_token(creds[\"username\"], creds[\"password\"])\n        for type_ in types_to_test:\n            item_data = sample_items[type_]\n\n            # Make the POST request to create the item\n            response = create_item(token, type_, item_data)\n\n            if user_key in authorized_users:\n                # Should be allowed to create, expect 200 and returned json object\n                try:\n                    assert response.status_code == 200, (\n                        f\"User '{user_key}' with role allowed to create '{type_}' \"\n                        f\"but got status {response.status_code}: {response.text}\"\n                    )\n                    # Response should be a JSON object\n                    resp_json = response.json()\n                    assert isinstance(resp_json, dict), \"Response JSON is not an object\"\n                    # We expect some kind of id or success info, but schema is flexible so accept any dict\n                except (AssertionError, ValueError) as err:\n                    raise AssertionError(f\"Authorized create failed: {err}\")\n\n                # Attempt to cleanup: delete created item if id is returned or try fetch created id from server\n                # Since API spec not explicit about return id, try to guess id or skip cleanup\n                # For test stability we try to delete if 'id' in resp_json\n                item_id = resp_json.get(\"id\")\n                if item_id:\n                    del_resp = delete_item(token, type_, item_id)\n                    try:\n                        assert del_resp.status_code == 200, (\n                            f\"Cleanup delete failed with status {del_resp.status_code}: {del_resp.text}\"\n                        )\n                        del_json = del_resp.json()\n                        assert del_json.get(\"success\") is True, \"Delete response 'success' is not True\"\n                    except (AssertionError, ValueError) as err:\n                        raise AssertionError(f\"Cleanup delete failed: {err}\")\n            else:\n                # Unauthorized user: expect 403 Forbidden\n                try:\n                    assert response.status_code == 403, (\n                        f\"User '{user_key}' without permission should get 403 for creating '{type_}', \"\n                        f\"got {response.status_code}: {response.text}\"\n                    )\n                except AssertionError as err:\n                    raise\n\ntest_create_new_shortcut_group_or_app_with_authorization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 22, in login_get_token\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3001/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 171, in <module>\n  File \"<string>\", line 126, in test_create_new_shortcut_group_or_app_with_authorization\n  File \"<string>\", line 28, in login_get_token\nRuntimeError: Login failed for user admin: 401 Client Error: Unauthorized for url: http://localhost:3001/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.058Z",
    "modified": "2025-12-13T14:23:42.148Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "b994a629-03e2-466a-b255-7768786692db",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC007-update existing shortcut group or app with authorization",
    "description": "Test the /api/shortcuts/{type}/{id} PUT endpoint to update existing shortcuts, groups, or apps by ID. Verify that only admin and demo users can update items, invalid types return 400, and non-existent items return 404.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\n# Credentials for different roles\nADMIN_CREDENTIALS = {\"username\": \"admin_test_user\", \"password\": \"AdminTestPass123!\"}\nDEMO_CREDENTIALS = {\"username\": \"demo_test_user\", \"password\": \"DemoTestPass123!\"}\nCLIENT_CREDENTIALS = {\"username\": \"client_test_user\", \"password\": \"ClientTestPass123!\"}\n\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef login(username, password):\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\"username\": username, \"password\": password}\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()[\"token\"], resp.json()[\"user\"][\"id\"]\n\n\ndef create_item(token, type_, data):\n    url = f\"{BASE_URL}/api/shortcuts/{type_}\"\n    headers = {\"Authorization\": f\"Bearer {token}\", **HEADERS}\n    resp = requests.post(url, json=data, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef update_item(token, type_, item_id, data):\n    url = f\"{BASE_URL}/api/shortcuts/{type_}/{item_id}\"\n    headers = {\"Authorization\": f\"Bearer {token}\", **HEADERS}\n    return requests.put(url, json=data, headers=headers, timeout=TIMEOUT)\n\n\ndef delete_item(token, type_, item_id):\n    url = f\"{BASE_URL}/api/shortcuts/{type_}/{item_id}\"\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n    resp.raise_for_status()\n\n\ndef test_TC007_update_existing_shortcut_group_or_app_with_authorization():\n    # Log in users\n    admin_token, _ = login(ADMIN_CREDENTIALS[\"username\"], ADMIN_CREDENTIALS[\"password\"])\n    demo_token, _ = login(DEMO_CREDENTIALS[\"username\"], DEMO_CREDENTIALS[\"password\"])\n    client_token, _ = login(CLIENT_CREDENTIALS[\"username\"], CLIENT_CREDENTIALS[\"password\"])\n\n    # We'll test update on a group type for simplicity; could test others similarly\n    type_ = \"groups\"\n\n    # Sample creation data for group (without id to auto-generate)\n    create_data = {\n        \"name\": \"Test Group\",\n        \"icon\": \"test-icon\",\n        \"color\": \"#123456\"\n    }\n\n    # Create item as admin to get valid ID for updates\n    created_item = None\n    item_id = None\n    try:\n        # Create with admin token\n        create_resp = create_item(admin_token, type_, create_data)\n        # No response schema detailed, assuming created item includes id (as usually expected)\n        # We'll attempt to get the id by fetching all groups or from creation response if possible\n        # Since response schema is generic object, try to find id or fallback to fetch all and find the created\n        # For test robustness, try fetching all groups first\n        # Fetch all shortcuts to find created item id\n        url_all = f\"{BASE_URL}/api/shortcuts\"\n        headers_admin = {\"Authorization\": f\"Bearer {admin_token}\"}\n        resp_all = requests.get(url_all, headers=headers_admin, timeout=TIMEOUT)\n        resp_all.raise_for_status()\n        data_all = resp_all.json()\n\n        groups = data_all.get(\"leaderGroups\", []) + data_all.get(\"raycastGroups\", []) + data_all.get(\"systemGroups\", []) + data_all.get(\"groups\", [])\n        # Try to locate the group matching the name created\n        for g in groups:\n            if g.get(\"name\") == create_data[\"name\"]:\n                item_id = g.get(\"id\")\n                created_item = g\n                break\n        assert item_id is not None, \"Created item ID not found\"\n\n        # Updated data for PUT request\n        update_data = {\n            \"name\": \"Updated Test Group\",\n            \"icon\": \"updated-icon\",\n            \"color\": \"#654321\"\n        }\n\n        # 1. Valid update by admin - expect 200\n        resp = update_item(admin_token, type_, item_id, update_data)\n        assert resp.status_code == 200, f\"Admin update failed with status {resp.status_code}\"\n\n        # 2. Valid update by demo user - expect 200\n        resp = update_item(demo_token, type_, item_id, update_data)\n        assert resp.status_code == 200, f\"Demo user update failed with status {resp.status_code}\"\n\n        # 3. Invalid type - expect 400\n        invalid_type = \"invalidType123\"\n        resp_invalid_type = update_item(admin_token, invalid_type, item_id, update_data)\n        assert resp_invalid_type.status_code == 400, f\"Expected 400 for invalid type, got {resp_invalid_type.status_code}\"\n\n        # 4. Non-existent item - expect 404\n        fake_id = \"0000000000abcdef00000000\"\n        resp_nonexistent = update_item(admin_token, type_, fake_id, update_data)\n        assert resp_nonexistent.status_code == 404, f\"Expected 404 for nonexistent id, got {resp_nonexistent.status_code}\"\n\n        # 5. Unauthorized user (client) tries update - expect 403\n        resp_unauth = update_item(client_token, type_, item_id, update_data)\n        assert resp_unauth.status_code == 403, f\"Expected 403 for unauthorized user, got {resp_unauth.status_code}\"\n\n    finally:\n        # Cleanup: delete the created item if it exists and token available\n        if item_id and admin_token:\n            try:\n                delete_item(admin_token, type_, item_id)\n            except Exception:\n                pass\n\n\ntest_TC007_update_existing_shortcut_group_or_app_with_authorization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 123, in <module>\n  File \"<string>\", line 45, in test_TC007_update_existing_shortcut_group_or_app_with_authorization\n  File \"<string>\", line 18, in login\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3001/api/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.064Z",
    "modified": "2025-12-13T14:23:44.140Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "aed04e15-28cb-4994-bbf9-813fab4f8787",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC008-delete shortcut group or app with authorization",
    "description": "Test the /api/shortcuts/{type}/{id} DELETE endpoint to delete shortcuts, groups, or apps by ID. Verify that only admin and demo users can delete items, invalid types return 400, and unauthorized attempts return 403.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\nADMIN_CREDENTIALS = {\"username\": \"admin\", \"password\": \"adminPass123\"}\nDEMO_CREDENTIALS = {\"username\": \"demo\", \"password\": \"demoPass123\"}\nCLIENT_CREDENTIALS = {\"username\": \"clientuser\", \"password\": \"clientPass123\"}  # Assuming client user\nGUEST_TOKEN = None  # No token for guest (unauthorized)\n\nVALID_TYPES = [\n    \"shortcuts\",\n    \"groups\",\n    \"apps\",\n    \"leaderShortcuts\",\n    \"raycastShortcuts\",\n    \"systemShortcuts\",\n    \"leaderGroups\",\n    \"raycastGroups\",\n    \"systemGroups\"\n]\n\nINVALID_TYPE = \"invalidTypeTest\"\n\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef login_get_token(username, password):\n    try:\n        resp = requests.post(\n            f\"{BASE_URL}/api/auth/login\",\n            json={\"username\": username, \"password\": password},\n            timeout=TIMEOUT,\n        )\n        resp.raise_for_status()\n        return resp.json().get(\"token\")\n    except Exception:\n        return None\n\n\ndef create_resource(token, type_, data):\n    headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n    response = requests.post(\n        f\"{BASE_URL}/api/shortcuts/{type_}\",\n        headers=headers,\n        json=data,\n        timeout=TIMEOUT,\n    )\n    response.raise_for_status()\n    return response.json()\n\n\ndef delete_resource(token, type_, id_):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    response = requests.delete(\n        f\"{BASE_URL}/api/shortcuts/{type_}/{id_}\", headers=headers, timeout=TIMEOUT\n    )\n    return response\n\n\ndef test_tc008_delete_shortcut_group_app_authorization():\n    # Login tokens for admin, demo and client users\n    admin_token = login_get_token(**ADMIN_CREDENTIALS)\n    demo_token = login_get_token(**DEMO_CREDENTIALS)\n    client_token = login_get_token(**CLIENT_CREDENTIALS)\n\n    assert admin_token is not None, \"Admin login failed\"\n    assert demo_token is not None, \"Demo login failed\"\n    assert client_token is not None, \"Client login failed\"\n\n    # Prepare a new item data for creation (choosing 'groups' as a type example)\n    type_ = \"groups\"\n    created_id = None\n    created_by_demo_id = None\n\n    # Sample valid group data without id (id auto-generated by server)\n    group_data = {\n        \"name\": f\"Test Group {uuid.uuid4()}\",\n        \"icon\": \"test-icon\",\n        \"color\": \"#abcdef\",\n    }\n\n    # Create resource with admin token\n    try:\n        # Create with admin\n        create_resp = create_resource(admin_token, type_, group_data)\n        # The API doc for create returns 200 with created item (no specific schema)\n        # Expect an 'id' in response or something similar; otherwise fallback to GET after creation\n        created_id = create_resp.get(\"id\")\n        assert created_id is not None, \"Failed to get created id for admin-created item\"\n\n        # Create resource with demo token\n        create_resp_demo = create_resource(demo_token, type_, group_data)\n        created_by_demo_id = create_resp_demo.get(\"id\")\n        assert created_by_demo_id is not None, \"Failed to get created id for demo-created item\"\n\n        # --- TEST: Admin user can delete the created item ---\n        resp = delete_resource(admin_token, type_, created_id)\n        assert resp.status_code == 200\n        resp_json = resp.json()\n        assert \"success\" in resp_json and resp_json[\"success\"] is True\n\n        # --- TEST: Demo user can delete the created item ---\n        resp_demo = delete_resource(demo_token, type_, created_by_demo_id)\n        assert resp_demo.status_code == 200\n        resp_demo_json = resp_demo.json()\n        assert \"success\" in resp_demo_json and resp_demo_json[\"success\"] is True\n\n        # --- TEST: Client user (unauthorized) tries to delete an item created by admin (should fail with 403) ---\n        # First recreate the resource to delete by client attempt\n        recreate_resp = create_resource(admin_token, type_, group_data)\n        temp_id = recreate_resp.get(\"id\")\n        assert temp_id is not None\n\n        resp_client = delete_resource(client_token, type_, temp_id)\n        assert resp_client.status_code == 403\n\n        # Cleanup: Delete the resource by admin\n        resp_clean = delete_resource(admin_token, type_, temp_id)\n        assert resp_clean.status_code == 200\n        resp_clean_json = resp_clean.json()\n        assert resp_clean_json.get(\"success\") is True\n\n        # --- TEST: Guest (no auth) attempts to delete (should get 403) ---\n        resp_guest = requests.delete(\n            f\"{BASE_URL}/api/shortcuts/{type_}/{temp_id}\", timeout=TIMEOUT\n        )\n        # API doc implies 403 for unauthorized; some APIs may return 401 for no auth; accept either\n        assert resp_guest.status_code in (401, 403)\n\n        # --- TEST: Invalid type parameter returns 400 ---\n        # Use admin token for auth\n        resp_invalid_type = delete_resource(admin_token, INVALID_TYPE, \"some-id\")\n        assert resp_invalid_type.status_code == 400\n\n    finally:\n        # Cleanup any leftovers in case deletes failed above\n        headers_admin = {\"Authorization\": f\"Bearer {admin_token}\"}\n        if created_id is not None:\n            requests.delete(\n                f\"{BASE_URL}/api/shortcuts/{type_}/{created_id}\",\n                headers=headers_admin,\n                timeout=TIMEOUT,\n            )\n        if created_by_demo_id is not None:\n            headers_demo = {\"Authorization\": f\"Bearer {demo_token}\"}\n            requests.delete(\n                f\"{BASE_URL}/api/shortcuts/{type_}/{created_by_demo_id}\",\n                headers=headers_demo,\n                timeout=TIMEOUT,\n            )\n\n\ntest_tc008_delete_shortcut_group_app_authorization()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 155, in <module>\n  File \"<string>\", line 68, in test_tc008_delete_shortcut_group_app_authorization\nAssertionError: Admin login failed\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.077Z",
    "modified": "2025-12-13T14:23:44.699Z"
  },
  {
    "projectId": "f0321bc6-bcf8-43d0-ba7a-a9a6bacb94e7",
    "testId": "14ed0044-5057-438c-9a71-d50cd86a5357",
    "userId": "d428b4a8-a0f1-70fb-ad1c-10ddcdd16b3f",
    "title": "TC009-proxy external image with valid url",
    "description": "Test the /api/proxy-image GET endpoint to fetch external images by providing a valid URL query parameter. Verify that the image data is returned correctly and that missing URL parameters return a 400 error.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3001\"\nTIMEOUT = 30\n\ndef test_proxy_external_image_with_valid_url():\n    # Valid image URL to proxy\n    valid_image_url = \"https://via.placeholder.com/150\"  # A placeholder image URL for testing\n    \n    # Test case: successful fetch with valid URL parameter\n    try:\n        response = requests.get(\n            f\"{BASE_URL}/api/proxy-image\",\n            params={\"url\": valid_image_url},\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n        content_type = response.headers.get(\"Content-Type\", \"\")\n        assert content_type.startswith(\"image/\"), f\"Expected image content type, got {content_type}\"\n        assert response.content and len(response.content) > 0, \"Expected non-empty image content\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    # Test case: missing URL parameter returns 400\n    try:\n        response = requests.get(\n            f\"{BASE_URL}/api/proxy-image\",\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 400, f\"Expected status 400 for missing url param, got {response.status_code}\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_proxy_external_image_with_valid_url()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 34, in <module>\n  File \"<string>\", line 17, in test_proxy_external_image_with_valid_url\nAssertionError: Expected status 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-12-13T14:22:49.083Z",
    "modified": "2025-12-13T14:23:58.671Z"
  }
]
